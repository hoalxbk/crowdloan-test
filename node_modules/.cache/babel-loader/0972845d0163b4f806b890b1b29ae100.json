{"ast":null,"code":"import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\"; // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\nimport { compactFromU8a, compactToU8a, isHex, isObject, isU8a, logger, stringify, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareMap, decodeU8a, typeToConstructor } from \"./utils/index.js\";\nconst l = logger('Map');\n/** @internal */\n\nfunction decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {\n  const output = new Map();\n  const [offset, length] = compactFromU8a(u8a);\n  const types = [];\n\n  for (let i = 0; i < length.toNumber(); i++) {\n    types.push(KeyClass, ValClass);\n  }\n\n  const values = decodeU8a(registry, u8a.subarray(offset), types);\n\n  for (let i = 0; i < values.length; i += 2) {\n    output.set(values[i], values[i + 1]);\n  }\n\n  return output;\n}\n/** @internal */\n\n\nfunction decodeMapFromMap(registry, KeyClass, ValClass, value) {\n  const output = new Map();\n  value.forEach((val, key) => {\n    try {\n      output.set(key instanceof KeyClass ? key : new KeyClass(registry, key), val instanceof ValClass ? val : new ValClass(registry, val));\n    } catch (error) {\n      l.error('Failed to decode key or value:', error.message);\n      throw error;\n    }\n  });\n  return output;\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param KeyClass - Type of the map key\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Map<any, any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonMap\n * @internal\n */\n\n\nfunction decodeMap(registry, keyType, valType, value) {\n  const KeyClass = typeToConstructor(registry, keyType);\n  const ValClass = typeToConstructor(registry, valType);\n\n  if (!value) {\n    return new Map();\n  } else if (isU8a(value) || isHex(value)) {\n    return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a(value));\n  } else if (value instanceof Map) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, value);\n  } else if (isObject(value)) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));\n  }\n\n  throw new Error('Map: cannot decode type');\n}\n\nvar _KeyClass = /*#__PURE__*/_classPrivateFieldLooseKey(\"KeyClass\");\n\nvar _ValClass = /*#__PURE__*/_classPrivateFieldLooseKey(\"ValClass\");\n\nvar _type = /*#__PURE__*/_classPrivateFieldLooseKey(\"type\");\n\nexport class CodecMap extends Map {\n  constructor(registry, keyType, valType, rawValue, type = 'HashMap') {\n    super(decodeMap(registry, keyType, valType, rawValue));\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _KeyClass, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ValClass, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass] = typeToConstructor(registry, keyType);\n    _classPrivateFieldLooseBase(this, _ValClass)[_ValClass] = typeToConstructor(registry, valType);\n    _classPrivateFieldLooseBase(this, _type)[_type] = type;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    let len = compactToU8a(this.size).length;\n    this.forEach((v, k) => {\n      len += v.encodedLength + k.encodedLength;\n    });\n    return len;\n  }\n  /**\n   * @description Returns a hash of the value\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return this.size === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    const json = {};\n    this.forEach((v, k) => {\n      json[k.toString()] = v.toHuman(isExtended);\n    });\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    const json = {};\n    this.forEach((v, k) => {\n      json[k.toString()] = v.toJSON();\n    });\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `${_classPrivateFieldLooseBase(this, _type)[_type]}<${this.registry.getClassName(_classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass]) || new (_classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass])(this.registry).toRawType()},${this.registry.getClassName(_classPrivateFieldLooseBase(this, _ValClass)[_ValClass]) || new (_classPrivateFieldLooseBase(this, _ValClass)[_ValClass])(this.registry).toRawType()}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = new Array();\n\n    if (!isBare) {\n      encoded.push(compactToU8a(this.size));\n    }\n\n    this.forEach((v, k) => {\n      encoded.push(k.toU8a(isBare), v.toU8a(isBare));\n    });\n    return u8aConcat(...encoded);\n  }\n\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/types/codec/Map.js"],"names":["_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","compactFromU8a","compactToU8a","isHex","isObject","isU8a","logger","stringify","u8aConcat","u8aToHex","u8aToU8a","compareMap","decodeU8a","typeToConstructor","l","decodeMapFromU8a","registry","KeyClass","ValClass","u8a","output","Map","offset","length","types","i","toNumber","push","values","subarray","set","decodeMapFromMap","value","forEach","val","key","error","message","decodeMap","keyType","valType","Object","entries","Error","_KeyClass","_ValClass","_type","CodecMap","constructor","rawValue","type","createdAtHash","defineProperty","writable","encodedLength","len","size","v","k","hash","toU8a","isEmpty","eq","other","toHex","toHuman","isExtended","json","toString","toJSON","toRawType","getClassName","isBare","encoded","Array"],"mappings":"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","sourcesContent":["import _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { compactFromU8a, compactToU8a, isHex, isObject, isU8a, logger, stringify, u8aConcat, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { compareMap, decodeU8a, typeToConstructor } from \"./utils/index.js\";\nconst l = logger('Map');\n/** @internal */\n\nfunction decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {\n  const output = new Map();\n  const [offset, length] = compactFromU8a(u8a);\n  const types = [];\n\n  for (let i = 0; i < length.toNumber(); i++) {\n    types.push(KeyClass, ValClass);\n  }\n\n  const values = decodeU8a(registry, u8a.subarray(offset), types);\n\n  for (let i = 0; i < values.length; i += 2) {\n    output.set(values[i], values[i + 1]);\n  }\n\n  return output;\n}\n/** @internal */\n\n\nfunction decodeMapFromMap(registry, KeyClass, ValClass, value) {\n  const output = new Map();\n  value.forEach((val, key) => {\n    try {\n      output.set(key instanceof KeyClass ? key : new KeyClass(registry, key), val instanceof ValClass ? val : new ValClass(registry, val));\n    } catch (error) {\n      l.error('Failed to decode key or value:', error.message);\n      throw error;\n    }\n  });\n  return output;\n}\n/**\n * Decode input to pass into constructor.\n *\n * @param KeyClass - Type of the map key\n * @param ValClass - Type of the map value\n * @param value - Value to decode, one of:\n * - null\n * - undefined\n * - hex\n * - Uint8Array\n * - Map<any, any>, where both key and value types are either\n *   constructors or decodeable values for their types.\n * @param jsonMap\n * @internal\n */\n\n\nfunction decodeMap(registry, keyType, valType, value) {\n  const KeyClass = typeToConstructor(registry, keyType);\n  const ValClass = typeToConstructor(registry, valType);\n\n  if (!value) {\n    return new Map();\n  } else if (isU8a(value) || isHex(value)) {\n    return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a(value));\n  } else if (value instanceof Map) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, value);\n  } else if (isObject(value)) {\n    return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));\n  }\n\n  throw new Error('Map: cannot decode type');\n}\n\nvar _KeyClass = /*#__PURE__*/_classPrivateFieldLooseKey(\"KeyClass\");\n\nvar _ValClass = /*#__PURE__*/_classPrivateFieldLooseKey(\"ValClass\");\n\nvar _type = /*#__PURE__*/_classPrivateFieldLooseKey(\"type\");\n\nexport class CodecMap extends Map {\n  constructor(registry, keyType, valType, rawValue, type = 'HashMap') {\n    super(decodeMap(registry, keyType, valType, rawValue));\n    this.registry = void 0;\n    this.createdAtHash = void 0;\n    Object.defineProperty(this, _KeyClass, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _ValClass, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _type, {\n      writable: true,\n      value: void 0\n    });\n    this.registry = registry;\n    _classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass] = typeToConstructor(registry, keyType);\n    _classPrivateFieldLooseBase(this, _ValClass)[_ValClass] = typeToConstructor(registry, valType);\n    _classPrivateFieldLooseBase(this, _type)[_type] = type;\n  }\n  /**\n   * @description The length of the value when encoded as a Uint8Array\n   */\n\n\n  get encodedLength() {\n    let len = compactToU8a(this.size).length;\n    this.forEach((v, k) => {\n      len += v.encodedLength + k.encodedLength;\n    });\n    return len;\n  }\n  /**\n   * @description Returns a hash of the value\n   */\n\n\n  get hash() {\n    return this.registry.hash(this.toU8a());\n  }\n  /**\n   * @description Checks if the value is an empty value\n   */\n\n\n  get isEmpty() {\n    return this.size === 0;\n  }\n  /**\n   * @description Compares the value of the input to see if there is a match\n   */\n\n\n  eq(other) {\n    return compareMap(this, other);\n  }\n  /**\n   * @description Returns a hex string representation of the value. isLe returns a LE (number-only) representation\n   */\n\n\n  toHex() {\n    return u8aToHex(this.toU8a());\n  }\n  /**\n   * @description Converts the Object to to a human-friendly JSON, with additional fields, expansion and formatting of information\n   */\n\n\n  toHuman(isExtended) {\n    const json = {};\n    this.forEach((v, k) => {\n      json[k.toString()] = v.toHuman(isExtended);\n    });\n    return json;\n  }\n  /**\n   * @description Converts the Object to JSON, typically used for RPC transfers\n   */\n\n\n  toJSON() {\n    const json = {};\n    this.forEach((v, k) => {\n      json[k.toString()] = v.toJSON();\n    });\n    return json;\n  }\n  /**\n   * @description Returns the base runtime type name for this instance\n   */\n\n\n  toRawType() {\n    return `${_classPrivateFieldLooseBase(this, _type)[_type]}<${this.registry.getClassName(_classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass]) || new (_classPrivateFieldLooseBase(this, _KeyClass)[_KeyClass])(this.registry).toRawType()},${this.registry.getClassName(_classPrivateFieldLooseBase(this, _ValClass)[_ValClass]) || new (_classPrivateFieldLooseBase(this, _ValClass)[_ValClass])(this.registry).toRawType()}>`;\n  }\n  /**\n   * @description Returns the string representation of the value\n   */\n\n\n  toString() {\n    return stringify(this.toJSON());\n  }\n  /**\n   * @description Encodes the value as a Uint8Array as per the SCALE specifications\n   * @param isBare true when the value has none of the type-specific prefixes (internal)\n   */\n\n\n  toU8a(isBare) {\n    const encoded = new Array();\n\n    if (!isBare) {\n      encoded.push(compactToU8a(this.size));\n    }\n\n    this.forEach((v, k) => {\n      encoded.push(k.toU8a(isBare), v.toU8a(isBare));\n    });\n    return u8aConcat(...encoded);\n  }\n\n}"]},"metadata":{},"sourceType":"module"}