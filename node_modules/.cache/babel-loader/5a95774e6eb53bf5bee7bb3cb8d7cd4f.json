{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { isFunction, stringToHex } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nconst DEMOCRACY_ID = stringToHex('democrac');\n\nfunction queryQueue(api) {\n  return api.query.democracy.dispatchQueue().pipe(switchMap(dispatches => combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))])), map(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({\n    at,\n    image: images[dispatchIndex],\n    imageHash,\n    index\n  }))));\n}\n\nfunction schedulerEntries(api) {\n  // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n  // the subscribe to those keys - this means we pickup when the schedulers actually executes\n  // at a block, the entry for that block will become empty\n  return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap(keys => {\n    const blockNumbers = keys.map(({\n      args: [blockNumber]\n    }) => blockNumber);\n    return combineLatest([of(blockNumbers), api.query.scheduler.agenda.multi(blockNumbers)]);\n  }));\n}\n\nfunction queryScheduler(api) {\n  return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {\n    const result = [];\n    blockNumbers.forEach((at, index) => {\n      agendas[index].filter(optScheduled => optScheduled.isSome).forEach(optScheduled => {\n        const scheduled = optScheduled.unwrap();\n\n        if (scheduled.maybeId.isSome) {\n          const id = scheduled.maybeId.unwrap().toHex();\n\n          if (id.startsWith(DEMOCRACY_ID)) {\n            const [, index] = api.registry.createType('(u64, ReferendumIndex)', id);\n            const imageHash = scheduled.call.args[0];\n            result.push({\n              at,\n              imageHash,\n              index\n            });\n          }\n        }\n      });\n    });\n    return combineLatest([of(result), api.derive.democracy.preimages(result.map(({\n      imageHash\n    }) => imageHash))]);\n  }), map(([infos, images]) => infos.map((info, index) => _objectSpread(_objectSpread({}, info), {}, {\n    image: images[index]\n  }))));\n}\n\nexport function dispatchQueue(instanceId, api) {\n  return memo(instanceId, () => {\n    var _api$query$scheduler;\n\n    return isFunction((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : of([]);\n  });\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/api-derive/democracy/dispatchQueue.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","isFunction","stringToHex","combineLatest","of","map","switchMap","memo","DEMOCRACY_ID","queryQueue","api","query","democracy","dispatchQueue","pipe","dispatches","derive","preimages","hash","images","at","imageHash","index","dispatchIndex","image","schedulerEntries","referendumsFinished","scheduler","agenda","blockNumbers","args","blockNumber","multi","queryScheduler","agendas","result","optScheduled","isSome","scheduled","unwrap","maybeId","id","toHex","startsWith","registry","createType","call","infos","info","instanceId","_api$query$scheduler"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api-derive authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { isFunction, stringToHex } from '@polkadot/util';\nimport { combineLatest, of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { memo } from \"../util/index.js\";\nconst DEMOCRACY_ID = stringToHex('democrac');\n\nfunction queryQueue(api) {\n  return api.query.democracy.dispatchQueue().pipe(switchMap(dispatches => combineLatest([of(dispatches), api.derive.democracy.preimages(dispatches.map(([, hash]) => hash))])), map(([dispatches, images]) => dispatches.map(([at, imageHash, index], dispatchIndex) => ({\n    at,\n    image: images[dispatchIndex],\n    imageHash,\n    index\n  }))));\n}\n\nfunction schedulerEntries(api) {\n  // We don't get entries, but rather we get the keys (triggered via finished referendums) and\n  // the subscribe to those keys - this means we pickup when the schedulers actually executes\n  // at a block, the entry for that block will become empty\n  return api.derive.democracy.referendumsFinished().pipe(switchMap(() => api.query.scheduler.agenda.keys()), switchMap(keys => {\n    const blockNumbers = keys.map(({\n      args: [blockNumber]\n    }) => blockNumber);\n    return combineLatest([of(blockNumbers), api.query.scheduler.agenda.multi(blockNumbers)]);\n  }));\n}\n\nfunction queryScheduler(api) {\n  return schedulerEntries(api).pipe(switchMap(([blockNumbers, agendas]) => {\n    const result = [];\n    blockNumbers.forEach((at, index) => {\n      agendas[index].filter(optScheduled => optScheduled.isSome).forEach(optScheduled => {\n        const scheduled = optScheduled.unwrap();\n\n        if (scheduled.maybeId.isSome) {\n          const id = scheduled.maybeId.unwrap().toHex();\n\n          if (id.startsWith(DEMOCRACY_ID)) {\n            const [, index] = api.registry.createType('(u64, ReferendumIndex)', id);\n            const imageHash = scheduled.call.args[0];\n            result.push({\n              at,\n              imageHash,\n              index\n            });\n          }\n        }\n      });\n    });\n    return combineLatest([of(result), api.derive.democracy.preimages(result.map(({\n      imageHash\n    }) => imageHash))]);\n  }), map(([infos, images]) => infos.map((info, index) => _objectSpread(_objectSpread({}, info), {}, {\n    image: images[index]\n  }))));\n}\n\nexport function dispatchQueue(instanceId, api) {\n  return memo(instanceId, () => {\n    var _api$query$scheduler;\n\n    return isFunction((_api$query$scheduler = api.query.scheduler) === null || _api$query$scheduler === void 0 ? void 0 : _api$query$scheduler.agenda) ? queryScheduler(api) : api.query.democracy.dispatchQueue ? queryQueue(api) : of([]);\n  });\n}"]},"metadata":{},"sourceType":"module"}