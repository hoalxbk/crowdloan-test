{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { assert, isNumber } from '@polkadot/util';\nimport { sanitize } from \"./sanitize.js\";\nimport { TypeDefInfo } from \"./types.js\";\nimport { typeSplit } from \"./typeSplit.js\";\nconst MAX_NESTED = 64;\n\nfunction isRustEnum(details) {\n  const values = Object.values(details);\n\n  if (values.some(v => isNumber(v))) {\n    assert(values.every(v => isNumber(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n} // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n//  { _enum: { A: 1, B: 2 } }\n\n\nfunction _decodeEnum(value, details, count) {\n  value.info = TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  if (Array.isArray(details)) {\n    value.sub = details.map((name, index) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  } else if (isRustEnum(details)) {\n    value.sub = Object.entries(details).map(([name, type], index) => _objectSpread(_objectSpread({}, getTypeDef(type || 'Null', {\n      name\n    }, count)), {}, {\n      index\n    }));\n  } else {\n    value.sub = Object.entries(details).map(([name, index]) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  }\n\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: TypeDefInfo.Plain,\n    name,\n    type: name\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.sub = keys.filter(name => !['_alias'].includes(name)).map(name => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(parsed[name], {\n    name\n  }, count));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  const [vecType, strLength, displayName] = type.substr(1, type.length - 2).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 256, () => `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 8192 && length % 8 === 0, () => `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  return type.substr(0, start.length) === start && type.substr(-1 * end.length) === end;\n}\n\nconst nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Option<', '>', TypeDefInfo.Option], ['Vec<', '>', TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nexport function getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = sanitize(_type);\n  const value = {\n    displayName,\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  assert(++count !== MAX_NESTED, 'getTypeDef: Maximum nested limit reached');\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/types/create/getTypeDef.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","assert","isNumber","sanitize","TypeDefInfo","typeSplit","MAX_NESTED","isRustEnum","details","values","some","v","every","_decodeEnum","value","count","info","Enum","Array","isArray","sub","map","name","index","Plain","type","entries","getTypeDef","_decodeSet","Set","_bitLength","startsWith","_decodeStruct","_","parsed","JSON","parse","alias","_alias","Map","undefined","includes","_decodeFixedVec","vecType","strLength","displayName","substr","split","parseInt","trim","_decodeTuple","subType","inner","_decodeAnyInt","clazz","_decodeInt","_decodeUInt","_decodeDoNotConstruct","NAME_LENGTH","hasWrapper","start","end","nestedExtraction","VecFixed","Struct","Tuple","BTreeMap","HashMap","Int","Result","UInt","DoNotConstruct","wrappedExtraction","BTreeSet","Compact","Linkage","Option","Vec","extractSubType","_type","nested","find","wrapped"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber } from '@polkadot/util';\nimport { sanitize } from \"./sanitize.js\";\nimport { TypeDefInfo } from \"./types.js\";\nimport { typeSplit } from \"./typeSplit.js\";\nconst MAX_NESTED = 64;\n\nfunction isRustEnum(details) {\n  const values = Object.values(details);\n\n  if (values.some(v => isNumber(v))) {\n    assert(values.every(v => isNumber(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');\n    return false;\n  }\n\n  return true;\n} // decode an enum of either of the following forms\n//  { _enum: ['A', 'B', 'C'] }\n//  { _enum: { A: AccountId, B: Balance, C: u32 } }\n//  { _enum: { A: 1, B: 2 } }\n\n\nfunction _decodeEnum(value, details, count) {\n  value.info = TypeDefInfo.Enum; // not as pretty, but remain compatible with oo7 for both struct and Array types\n\n  if (Array.isArray(details)) {\n    value.sub = details.map((name, index) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  } else if (isRustEnum(details)) {\n    value.sub = Object.entries(details).map(([name, type], index) => _objectSpread(_objectSpread({}, getTypeDef(type || 'Null', {\n      name\n    }, count)), {}, {\n      index\n    }));\n  } else {\n    value.sub = Object.entries(details).map(([name, index]) => ({\n      index,\n      info: TypeDefInfo.Plain,\n      name,\n      type: 'Null'\n    }));\n  }\n\n  return value;\n} // decode a set of the form\n//   { _set: { A: 0b0001, B: 0b0010, C: 0b0100 } }\n\n\nfunction _decodeSet(value, details) {\n  value.info = TypeDefInfo.Set;\n  value.length = details._bitLength;\n  value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({\n    index,\n    info: TypeDefInfo.Plain,\n    name,\n    type: name\n  }));\n  return value;\n} // decode a struct, set or enum\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeStruct(value, type, _, count) {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n  const parsed = JSON.parse(type);\n  const keys = Object.keys(parsed);\n\n  if (keys.length === 1 && keys[0] === '_enum') {\n    return _decodeEnum(value, parsed[keys[0]], count);\n  } else if (keys.length === 1 && keys[0] === '_set') {\n    return _decodeSet(value, parsed[keys[0]]);\n  }\n\n  value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;\n  value.sub = keys.filter(name => !['_alias'].includes(name)).map(name => // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  getTypeDef(parsed[name], {\n    name\n  }, count));\n  return value;\n} // decode a fixed vector, e.g. [u8;32]\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeFixedVec(value, type, _, count) {\n  const [vecType, strLength, displayName] = type.substr(1, type.length - 2).split(';');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 256, () => `${type}: Only support for [Type; <length>], where length <= 256`);\n  value.displayName = displayName;\n  value.length = length; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  value.sub = getTypeDef(vecType, {}, count);\n  return value;\n} // decode a tuple\n\n\nfunction _decodeTuple(value, _, subType, count) {\n  value.sub = subType.length === 0 ? [] // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));\n  return value;\n} // decode a Int/UInt<bitLength[, name]>\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeAnyInt(value, type, _, clazz) {\n  const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');\n  const length = parseInt(strLength.trim(), 10); // as a first round, only u8 via u8aFixed, we can add more support\n\n  assert(length <= 8192 && length % 8 === 0, () => `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);\n  value.displayName = displayName;\n  value.length = length;\n  return value;\n}\n\nfunction _decodeInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'Int');\n}\n\nfunction _decodeUInt(value, type, subType) {\n  return _decodeAnyInt(value, type, subType, 'UInt');\n} // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\nfunction _decodeDoNotConstruct(value, type, _) {\n  const NAME_LENGTH = 'DoNotConstruct'.length;\n  value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);\n  return value;\n}\n\nfunction hasWrapper(type, [start, end]) {\n  return type.substr(0, start.length) === start && type.substr(-1 * end.length) === end;\n}\n\nconst nestedExtraction = [['[', ']', TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', TypeDefInfo.Struct, _decodeStruct], ['(', ')', TypeDefInfo.Tuple, _decodeTuple], // the inner for these are the same as tuple, multiple values\n['BTreeMap<', '>', TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', TypeDefInfo.Int, _decodeInt], ['Result<', '>', TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];\nconst wrappedExtraction = [['BTreeSet<', '>', TypeDefInfo.BTreeSet], ['Compact<', '>', TypeDefInfo.Compact], ['Linkage<', '>', TypeDefInfo.Linkage], ['Option<', '>', TypeDefInfo.Option], ['Vec<', '>', TypeDefInfo.Vec]];\n\nfunction extractSubType(type, [start, end]) {\n  return type.substr(start.length, type.length - start.length - end.length);\n} // eslint-disable-next-line @typescript-eslint/ban-types\n\n\nexport function getTypeDef(_type, {\n  displayName,\n  name\n} = {}, count = 0) {\n  // create the type via Type, allowing types to be sanitized\n  const type = sanitize(_type);\n  const value = {\n    displayName,\n    info: TypeDefInfo.Plain,\n    name,\n    type\n  };\n  assert(++count !== MAX_NESTED, 'getTypeDef: Maximum nested limit reached');\n  const nested = nestedExtraction.find(nested => hasWrapper(type, nested));\n\n  if (nested) {\n    value.info = nested[2];\n    return nested[3](value, type, extractSubType(type, nested), count);\n  }\n\n  const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));\n\n  if (wrapped) {\n    value.info = wrapped[2];\n    value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);\n  }\n\n  return value;\n}"]},"metadata":{},"sourceType":"module"}