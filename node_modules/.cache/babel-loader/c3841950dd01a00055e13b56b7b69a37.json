{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isUndefined, stringify } from '@polkadot/util';\nimport { BTreeMap, BTreeSet, CodecSet, Compact, Enum, HashMap, Int, Option, Result, Struct, Tuple, U8aFixed, UInt, Vec, VecFixed } from \"../codec/index.js\";\nimport { DoNotConstruct } from \"../primitive/index.js\";\nimport { getTypeDef } from \"./getTypeDef.js\";\nimport { TypeDefInfo } from \"./types.js\";\nexport function createClass(registry, type) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return getTypeClass(registry, getTypeDef(type));\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, if it cannot be parsed, it will yield\n// a runtime error.\n\nexport function ClassOfUnsafe(registry, name) {\n  return createClass(registry, name);\n} // alias for createClass\n\nexport function ClassOf(registry, name) {\n  // TS2589: Type instantiation is excessively deep and possibly infinite.\n  // The above happens with as Constructor<InterfaceTypes[K]>;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return ClassOfUnsafe(registry, name);\n}\n\nfunction getSubDefArray(value) {\n  assert(value.sub && Array.isArray(value.sub), () => `Expected subtype as TypeDef[] in ${stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubDef(value) {\n  assert(value.sub && !Array.isArray(value.sub), () => `Expected subtype as TypeDef in ${stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubType(value) {\n  return getSubDef(value).type;\n} // create a maps of type string constructors from the input\n\n\nfunction getTypeClassMap(value) {\n  const result = {};\n  return getSubDefArray(value).reduce((result, sub) => {\n    result[sub.name] = sub.type;\n    return result;\n  }, result);\n} // create an array of type string constructors from the input\n\n\nfunction getTypeClassArray(value) {\n  return getSubDefArray(value).map(({\n    type\n  }) => type);\n}\n\nfunction createInt({\n  displayName,\n  length\n}, Clazz) {\n  assert(isNumber(length), () => `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);\n  return Clazz.with(length, displayName);\n}\n\nfunction createHashMap(value, Clazz) {\n  const [keyType, valueType] = getTypeClassArray(value);\n  return Clazz.with(keyType, valueType);\n}\n\nconst infoMapping = {\n  [TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(value, BTreeMap),\n  [TypeDefInfo.BTreeSet]: (registry, value) => BTreeSet.with(getSubType(value)),\n  [TypeDefInfo.Compact]: (registry, value) => Compact.with(getSubType(value)),\n  [TypeDefInfo.DoNotConstruct]: (registry, value) => DoNotConstruct.with(value.displayName),\n  [TypeDefInfo.Enum]: (registry, value) => {\n    const subs = getSubDefArray(value);\n    return Enum.with(subs.every(({\n      type\n    }) => type === 'Null') ? subs.reduce((out, {\n      index,\n      name\n    }, count) => {\n      out[name] = index || count;\n      return out;\n    }, {}) : getTypeClassMap(value));\n  },\n  [TypeDefInfo.HashMap]: (registry, value) => createHashMap(value, HashMap),\n  [TypeDefInfo.Int]: (registry, value) => createInt(value, Int),\n  // We have circular deps between Linkage & Struct\n  [TypeDefInfo.Linkage]: (registry, value) => {\n    const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys\n\n    const Clazz = Struct.with({\n      previous: type,\n      next: type\n    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n    Clazz.prototype.toRawType = function () {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n      return `Linkage<${this.next.toRawType(true)}>`;\n    };\n\n    return Clazz;\n  },\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: (registry, _) => createClass(registry, 'Null'),\n  [TypeDefInfo.Option]: (registry, value) => Option.with(getSubType(value)),\n  [TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),\n  [TypeDefInfo.Result]: (registry, value) => {\n    const [Ok, Err] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    return Result.with({\n      Err,\n      Ok\n    });\n  },\n  [TypeDefInfo.Set]: (registry, value) => {\n    const result = {};\n    return CodecSet.with(getSubDefArray(value).reduce((result, {\n      index,\n      name\n    }) => {\n      result[name] = index;\n      return result;\n    }, result), value.length);\n  },\n  [TypeDefInfo.Struct]: (registry, value) => Struct.with(getTypeClassMap(value), value.alias),\n  [TypeDefInfo.Tuple]: (registry, value) => Tuple.with(getTypeClassArray(value)),\n  [TypeDefInfo.UInt]: (registry, value) => createInt(value, UInt),\n  [TypeDefInfo.Vec]: (registry, value) => {\n    const subType = getSubType(value);\n    return subType === 'u8' ? createClass(registry, 'Bytes') : Vec.with(subType);\n  },\n  [TypeDefInfo.VecFixed]: (registry, {\n    displayName,\n    length,\n    sub\n  }) => {\n    assert(isNumber(length) && !isUndefined(sub), 'Expected length & type information for fixed vector');\n    return sub.type === 'u8' ? U8aFixed.with(length * 8, displayName) : VecFixed.with(sub.type, length);\n  }\n}; // Returns the type Class for construction\n\nexport function getTypeClass(registry, value) {\n  const Type = registry.get(value.type);\n\n  if (Type) {\n    return Type;\n  }\n\n  const getFn = infoMapping[value.info];\n  assert(getFn, () => `Unable to construct class from ${stringify(value)}`);\n  return getFn(registry, value);\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/types/create/createClass.js"],"names":["assert","isNumber","isUndefined","stringify","BTreeMap","BTreeSet","CodecSet","Compact","Enum","HashMap","Int","Option","Result","Struct","Tuple","U8aFixed","UInt","Vec","VecFixed","DoNotConstruct","getTypeDef","TypeDefInfo","createClass","registry","type","getTypeClass","ClassOfUnsafe","name","ClassOf","getSubDefArray","value","sub","Array","isArray","getSubDef","getSubType","getTypeClassMap","result","reduce","getTypeClassArray","map","createInt","displayName","length","Clazz","constructor","with","createHashMap","keyType","valueType","infoMapping","subs","every","out","index","count","Linkage","previous","next","prototype","toRawType","Null","_","Plain","getOrUnknown","Ok","Err","Set","alias","subType","Type","get","getFn","info"],"mappings":"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","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isNumber, isUndefined, stringify } from '@polkadot/util';\nimport { BTreeMap, BTreeSet, CodecSet, Compact, Enum, HashMap, Int, Option, Result, Struct, Tuple, U8aFixed, UInt, Vec, VecFixed } from \"../codec/index.js\";\nimport { DoNotConstruct } from \"../primitive/index.js\";\nimport { getTypeDef } from \"./getTypeDef.js\";\nimport { TypeDefInfo } from \"./types.js\";\nexport function createClass(registry, type) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return getTypeClass(registry, getTypeDef(type));\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, if it cannot be parsed, it will yield\n// a runtime error.\n\nexport function ClassOfUnsafe(registry, name) {\n  return createClass(registry, name);\n} // alias for createClass\n\nexport function ClassOf(registry, name) {\n  // TS2589: Type instantiation is excessively deep and possibly infinite.\n  // The above happens with as Constructor<InterfaceTypes[K]>;\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n  return ClassOfUnsafe(registry, name);\n}\n\nfunction getSubDefArray(value) {\n  assert(value.sub && Array.isArray(value.sub), () => `Expected subtype as TypeDef[] in ${stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubDef(value) {\n  assert(value.sub && !Array.isArray(value.sub), () => `Expected subtype as TypeDef in ${stringify(value)}`);\n  return value.sub;\n}\n\nfunction getSubType(value) {\n  return getSubDef(value).type;\n} // create a maps of type string constructors from the input\n\n\nfunction getTypeClassMap(value) {\n  const result = {};\n  return getSubDefArray(value).reduce((result, sub) => {\n    result[sub.name] = sub.type;\n    return result;\n  }, result);\n} // create an array of type string constructors from the input\n\n\nfunction getTypeClassArray(value) {\n  return getSubDefArray(value).map(({\n    type\n  }) => type);\n}\n\nfunction createInt({\n  displayName,\n  length\n}, Clazz) {\n  assert(isNumber(length), () => `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);\n  return Clazz.with(length, displayName);\n}\n\nfunction createHashMap(value, Clazz) {\n  const [keyType, valueType] = getTypeClassArray(value);\n  return Clazz.with(keyType, valueType);\n}\n\nconst infoMapping = {\n  [TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(value, BTreeMap),\n  [TypeDefInfo.BTreeSet]: (registry, value) => BTreeSet.with(getSubType(value)),\n  [TypeDefInfo.Compact]: (registry, value) => Compact.with(getSubType(value)),\n  [TypeDefInfo.DoNotConstruct]: (registry, value) => DoNotConstruct.with(value.displayName),\n  [TypeDefInfo.Enum]: (registry, value) => {\n    const subs = getSubDefArray(value);\n    return Enum.with(subs.every(({\n      type\n    }) => type === 'Null') ? subs.reduce((out, {\n      index,\n      name\n    }, count) => {\n      out[name] = index || count;\n      return out;\n    }, {}) : getTypeClassMap(value));\n  },\n  [TypeDefInfo.HashMap]: (registry, value) => createHashMap(value, HashMap),\n  [TypeDefInfo.Int]: (registry, value) => createInt(value, Int),\n  // We have circular deps between Linkage & Struct\n  [TypeDefInfo.Linkage]: (registry, value) => {\n    const type = `Option<${getSubType(value)}>`; // eslint-disable-next-line sort-keys\n\n    const Clazz = Struct.with({\n      previous: type,\n      next: type\n    }); // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\n    Clazz.prototype.toRawType = function () {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call\n      return `Linkage<${this.next.toRawType(true)}>`;\n    };\n\n    return Clazz;\n  },\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [TypeDefInfo.Null]: (registry, _) => createClass(registry, 'Null'),\n  [TypeDefInfo.Option]: (registry, value) => Option.with(getSubType(value)),\n  [TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),\n  [TypeDefInfo.Result]: (registry, value) => {\n    const [Ok, Err] = getTypeClassArray(value); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    return Result.with({\n      Err,\n      Ok\n    });\n  },\n  [TypeDefInfo.Set]: (registry, value) => {\n    const result = {};\n    return CodecSet.with(getSubDefArray(value).reduce((result, {\n      index,\n      name\n    }) => {\n      result[name] = index;\n      return result;\n    }, result), value.length);\n  },\n  [TypeDefInfo.Struct]: (registry, value) => Struct.with(getTypeClassMap(value), value.alias),\n  [TypeDefInfo.Tuple]: (registry, value) => Tuple.with(getTypeClassArray(value)),\n  [TypeDefInfo.UInt]: (registry, value) => createInt(value, UInt),\n  [TypeDefInfo.Vec]: (registry, value) => {\n    const subType = getSubType(value);\n    return subType === 'u8' ? createClass(registry, 'Bytes') : Vec.with(subType);\n  },\n  [TypeDefInfo.VecFixed]: (registry, {\n    displayName,\n    length,\n    sub\n  }) => {\n    assert(isNumber(length) && !isUndefined(sub), 'Expected length & type information for fixed vector');\n    return sub.type === 'u8' ? U8aFixed.with(length * 8, displayName) : VecFixed.with(sub.type, length);\n  }\n}; // Returns the type Class for construction\n\nexport function getTypeClass(registry, value) {\n  const Type = registry.get(value.type);\n\n  if (Type) {\n    return Type;\n  }\n\n  const getFn = infoMapping[value.info];\n  assert(getFn, () => `Unable to construct class from ${stringify(value)}`);\n  return getFn(registry, value);\n}"]},"metadata":{},"sourceType":"module"}