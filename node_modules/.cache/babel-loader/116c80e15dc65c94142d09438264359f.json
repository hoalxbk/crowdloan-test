{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { getModuleTypes } from '@polkadot/types-known';\nimport { stringCamelCase } from '@polkadot/util'; // Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\n\nconst KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n};\nconst BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes, types) {\n  types.forEach(type => {\n    const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n\n    if (override) {\n      type.setOverride(sectionTypes[override]);\n    } else {\n      // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n      const orig = type.toString();\n      const alias = Object.entries(sectionTypes).reduce((result, [from, to]) => BOXES.reduce((result, [one, two]) => result.replace(`${one}${from}${two}`, `${one}${to}${two}`), result), orig);\n\n      if (orig !== alias) {\n        type.setOverride(alias);\n      }\n    }\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(c => {\n    setTypeOverride(sectionTypes, c.args.map(({\n      type\n    }) => type));\n    return registry.createType('FunctionMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n */\n\n\nfunction convertConstants(registry, constants, sectionTypes) {\n  return constants.map(c => {\n    setTypeOverride(sectionTypes, [c.type]);\n    return registry.createType('ModuleConstantMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(e => {\n    setTypeOverride(sectionTypes, e.args.map(type => type));\n    return registry.createType('EventMetadataLatest', e);\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(s => {\n      setTypeOverride(sectionTypes, s.type.isPlain ? [s.type.asPlain] : s.type.isMap ? [s.type.asMap.value, s.type.asMap.key] : s.type.isDoubleMap ? [s.type.asDoubleMap.value, s.type.asDoubleMap.key1, s.type.asDoubleMap.key2] : [s.type.asNMap.value, ...s.type.asNMap.keyVec]);\n      return registry.createType('StorageEntryMetadataLatest', s);\n    }),\n    prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules, metaVersion) {\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/** @internal */\n\n\nfunction createModule(registry, mod, {\n  calls,\n  constants,\n  events,\n  storage\n}) {\n  const sectionTypes = getModuleTypes(registry, stringCamelCase(mod.name));\n  return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n    calls: calls && convertCalls(registry, calls, sectionTypes),\n    constants: convertConstants(registry, constants, sectionTypes),\n    events: events && convertEvents(registry, events, sectionTypes),\n    storage: storage && convertStorage(registry, storage, sectionTypes)\n  }));\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nexport function toLatest(registry, {\n  extrinsic,\n  modules\n}, metaVersion) {\n  registerOriginCaller(registry, modules, metaVersion);\n  return registry.createType('MetadataLatest', {\n    extrinsic,\n    modules: modules.map(mod => createModule(registry, mod, {\n      calls: mod.calls.unwrapOr(null),\n      constants: mod.constants,\n      events: mod.events.unwrapOr(null),\n      storage: mod.storage.unwrapOr(null)\n    }))\n  });\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/metadata/v13/toLatest.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","getModuleTypes","stringCamelCase","KNOWN_ORIGINS","Council","System","TechnicalCommittee","BOXES","setTypeOverride","sectionTypes","types","type","override","find","aliased","eq","setOverride","orig","toString","alias","entries","reduce","result","from","to","one","two","replace","convertCalls","registry","calls","map","c","args","createType","convertConstants","constants","convertEvents","events","e","convertStorage","items","prefix","s","isPlain","asPlain","isMap","asMap","value","isDoubleMap","asDoubleMap","key1","key2","asNMap","keyVec","registerOriginCaller","modules","metaVersion","register","OriginCaller","_enum","mod","index","name","toNumber","sort","a","b","createModule","storage","toLatest","extrinsic","unwrapOr"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { getModuleTypes } from '@polkadot/types-known';\nimport { stringCamelCase } from '@polkadot/util'; // Since we don't have insight into the origin specification, we can only define what we know about\n// in a pure Substrate/Polkadot implementation, any other custom origins won't be handled at all\n\nconst KNOWN_ORIGINS = {\n  Council: 'CollectiveOrigin',\n  System: 'SystemOrigin',\n  TechnicalCommittee: 'CollectiveOrigin'\n};\nconst BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];\n/**\n * Find and apply the correct type override\n * @internal\n **/\n\nfunction setTypeOverride(sectionTypes, types) {\n  types.forEach(type => {\n    const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));\n\n    if (override) {\n      type.setOverride(sectionTypes[override]);\n    } else {\n      // FIXME: NOT happy with this approach, but gets over the initial hump cased by (Vec<Announcement>,BalanceOf)\n      const orig = type.toString();\n      const alias = Object.entries(sectionTypes).reduce((result, [from, to]) => BOXES.reduce((result, [one, two]) => result.replace(`${one}${from}${two}`, `${one}${to}${two}`), result), orig);\n\n      if (orig !== alias) {\n        type.setOverride(alias);\n      }\n    }\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertCalls(registry, calls, sectionTypes) {\n  return calls.map(c => {\n    setTypeOverride(sectionTypes, c.args.map(({\n      type\n    }) => type));\n    return registry.createType('FunctionMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n */\n\n\nfunction convertConstants(registry, constants, sectionTypes) {\n  return constants.map(c => {\n    setTypeOverride(sectionTypes, [c.type]);\n    return registry.createType('ModuleConstantMetadataLatest', c);\n  });\n}\n/**\n * Apply module-specific type overrides (always be done as part of toLatest)\n * @internal\n **/\n\n\nfunction convertEvents(registry, events, sectionTypes) {\n  return events.map(e => {\n    setTypeOverride(sectionTypes, e.args.map(type => type));\n    return registry.createType('EventMetadataLatest', e);\n  });\n}\n/**\n * Apply module-specific storage type overrides (always part of toLatest)\n * @internal\n **/\n\n\nfunction convertStorage(registry, {\n  items,\n  prefix\n}, sectionTypes) {\n  return registry.createType('StorageMetadataLatest', {\n    items: items.map(s => {\n      setTypeOverride(sectionTypes, s.type.isPlain ? [s.type.asPlain] : s.type.isMap ? [s.type.asMap.value, s.type.asMap.key] : s.type.isDoubleMap ? [s.type.asDoubleMap.value, s.type.asDoubleMap.key1, s.type.asDoubleMap.key2] : [s.type.asNMap.value, ...s.type.asNMap.keyVec]);\n      return registry.createType('StorageEntryMetadataLatest', s);\n    }),\n    prefix\n  });\n} // generate & register the OriginCaller type\n\n\nfunction registerOriginCaller(registry, modules, metaVersion) {\n  registry.register({\n    OriginCaller: {\n      _enum: modules.map((mod, index) => [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {\n        for (let i = Object.keys(result).length; i < index; i++) {\n          result[`Empty${i}`] = 'Null';\n        }\n\n        result[name] = KNOWN_ORIGINS[name] || 'Null';\n        return result;\n      }, {})\n    }\n  });\n}\n/** @internal */\n\n\nfunction createModule(registry, mod, {\n  calls,\n  constants,\n  events,\n  storage\n}) {\n  const sectionTypes = getModuleTypes(registry, stringCamelCase(mod.name));\n  return registry.createType('ModuleMetadataLatest', _objectSpread(_objectSpread({}, mod), {}, {\n    calls: calls && convertCalls(registry, calls, sectionTypes),\n    constants: convertConstants(registry, constants, sectionTypes),\n    events: events && convertEvents(registry, events, sectionTypes),\n    storage: storage && convertStorage(registry, storage, sectionTypes)\n  }));\n}\n/**\n * Convert the Metadata (which is an alias) to latest - effectively this _always_ get applied to the top-level &\n * most-recent metadata, since it allows us a chance to actually apply call and storage specific type aliasses\n * @internal\n **/\n\n\nexport function toLatest(registry, {\n  extrinsic,\n  modules\n}, metaVersion) {\n  registerOriginCaller(registry, modules, metaVersion);\n  return registry.createType('MetadataLatest', {\n    extrinsic,\n    modules: modules.map(mod => createModule(registry, mod, {\n      calls: mod.calls.unwrapOr(null),\n      constants: mod.constants,\n      events: mod.events.unwrapOr(null),\n      storage: mod.storage.unwrapOr(null)\n    }))\n  });\n}"]},"metadata":{},"sourceType":"module"}