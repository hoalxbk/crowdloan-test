{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { Metadata } from '@polkadot/metadata';\nimport { TypeRegistry } from '@polkadot/types/create';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, stringify, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nconst KEEPALIVE_INTERVAL = 10000;\nconst l = logger('api/init');\n\nvar _healthTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = /*#__PURE__*/_classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this.emit('connected');\n\n        this._isConnected.next(true);\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n\n          _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = setInterval(() => {\n            this._rpcCore.system.health().toPromise().catch(error => l.warn(`Health keepalive check failed: ${error.message}`));\n          }, KEEPALIVE_INTERVAL);\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          l.error(_error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this.emit('disconnected');\n\n        this._isConnected.next(false);\n\n        this._unsubscribeHealth();\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n    return registry;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      lastBlockHash\n    }) => lastBlockHash && u8aEq(lastBlockHash, blockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await this._rpcCore.chain.getHeader.json(blockHash).toPromise());\n    assert(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await this._rpcCore.state.getRuntimeVersion.json(header.parentHash).toPromise()); // check for pre-existing registries\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      specVersion\n    }) => specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = blockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const metadata = new Metadata(this.registry, await this._rpcCore.state.getMetadata.raw(header.parentHash).toPromise());\n\n    const registry = this._initRegistry(new TypeRegistry(blockHash), this._runtimeChain, version, metadata); // add our new registry\n\n\n    const result = {\n      isDefault: false,\n      lastBlockHash: blockHash,\n      metadata,\n      metadataConsts: null,\n      registry,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result); // TODO This could be useful for historic, disabled due to cross-looping, i.e. .at queries\n    // this._detectCapabilities(registry, blockHash);\n\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source; // on re-connection to the same chain, we don't want to re-do everything from chain again\n\n\n    if (this._isReady) {\n      return true;\n    }\n\n    this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpcMethods(methods);\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    detectedCapabilities(this._rx, blockHash).toPromise().then(types => {\n      if (Object.keys(types).length) {\n        registry.register(types);\n        l.debug(() => `Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${stringify(types)}`);\n      }\n    }).catch(undefined);\n    return true;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n            isDefault\n          }) => isDefault);\n\n          assert(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.metadataConsts = null;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this.injectMetadata(metadata, false, thisRegistry.registry);\n          return this._detectCapabilities(thisRegistry.registry);\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([this._rpcCore.chain.getBlockHash(0).toPromise(), this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise(), this._rpcCore.rpc.methods().toPromise(), optMetadata ? Promise.resolve(null) : this._rpcCore.state.getMetadata().toPromise()]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise()); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods, getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        lastBlockHash: null,\n        metadata,\n        metadataConsts: null,\n        registry: this.registry,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(false);\n    return [genesisHash, metadata];\n  }\n\n  _initFromMeta(metadata) {\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities\n\n    this._detectCapabilities(this.registry);\n\n    return true;\n  }\n\n  _unsubscribeHealth() {\n    if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n      clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n      _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n    }\n  }\n\n  _unsubscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = null;\n    }\n  }\n\n  _unsubscribe() {\n    this._unsubscribeHealth();\n\n    this._unsubscribeUpdates();\n  }\n\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/api/base/Init.js"],"names":["_defineProperty","_classPrivateFieldLooseBase","_classPrivateFieldLooseKey","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","Metadata","TypeRegistry","getSpecAlias","getSpecExtensions","getSpecHasher","getSpecRpc","getSpecTypes","getUpgradeVersion","assert","BN_ZERO","logger","stringify","u8aEq","u8aToHex","u8aToU8a","cryptoWaitReady","of","map","switchMap","detectedCapabilities","Decorate","KEEPALIVE_INTERVAL","l","_healthTimer","_registries","_updateSub","_onProviderConnect","_onProviderDisconnect","_onProviderError","Init","constructor","options","type","decorateMethod","writable","value","emit","_isConnected","next","hasMeta","cryptoReady","Promise","all","_loadMeta","_options","initWasm","resolve","_isReady","setInterval","_rpcCore","system","health","toPromise","catch","error","warn","message","_error","Error","_unsubscribeHealth","registry","setKnownTypes","registerTypes","types","_rpc","_decorateRpc","_decorateMethod","_rx","rpc","_rxDecorateMethod","supportMulti","_queryMulti","_decorateMulti","queryMulti","signer","setRegistrySwap","blockHash","getBlockRegistry","hasSubscriptions","provider","on","isConnected","_initRegistry","chain","version","metadata","chainProps","setChainProperties","getChainProperties","register","specName","specVersion","setHasher","knownTypes","typesBundle","typesAlias","setMetadata","undefined","signedExtensions","existingViaHash","find","lastBlockHash","_genesisHash","_runtimeVersion","header","createType","eq","number","parentHash","getHeader","json","isEmpty","firstVersion","lastVersion","state","getRuntimeVersion","existingViaVersion","getMetadata","raw","_runtimeChain","result","isDefault","metadataConsts","_this$_options$source","_unsubscribeUpdates","_runtimeMetadata","_metaFromSource","_metaFromChain","_initFromMeta","_extrinsicType","extrinsicVersion","runtimeChain","runtimeVersion","methods","section","method","_filterRpcMethods","genesisHash","runtimeMetadata","_detectCapabilities","then","debug","_subscribeUpdates","subscribeRuntimeVersion","pipe","_this$_runtimeVersion","log","toString","transactionVersion","thisRegistry","init","injectMetadata","subscribe","optMetadata","rpcMethods","chainMetadata","getBlockHash","properties","metadataKey","toHex","_filterRpc","getUniqTypes","asLatest","extrinsic","toNumber","extrinsicType","derive","_decorateDeriveRx","_derive","_decorateDerive","clearInterval","unsubscribe","_unsubscribe"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _classPrivateFieldLooseBase from \"@babel/runtime/helpers/esm/classPrivateFieldLooseBase\";\nimport _classPrivateFieldLooseKey from \"@babel/runtime/helpers/esm/classPrivateFieldLooseKey\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/api authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { Metadata } from '@polkadot/metadata';\nimport { TypeRegistry } from '@polkadot/types/create';\nimport { getSpecAlias, getSpecExtensions, getSpecHasher, getSpecRpc, getSpecTypes, getUpgradeVersion } from '@polkadot/types-known';\nimport { assert, BN_ZERO, logger, stringify, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { cryptoWaitReady } from '@polkadot/util-crypto';\nimport { of } from '@polkadot/x-rxjs';\nimport { map, switchMap } from '@polkadot/x-rxjs/operators';\nimport { detectedCapabilities } from \"./capabilities.js\";\nimport { Decorate } from \"./Decorate.js\";\nconst KEEPALIVE_INTERVAL = 10000;\nconst l = logger('api/init');\n\nvar _healthTimer = /*#__PURE__*/_classPrivateFieldLooseKey(\"healthTimer\");\n\nvar _registries = /*#__PURE__*/_classPrivateFieldLooseKey(\"registries\");\n\nvar _updateSub = /*#__PURE__*/_classPrivateFieldLooseKey(\"updateSub\");\n\nvar _onProviderConnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderConnect\");\n\nvar _onProviderDisconnect = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderDisconnect\");\n\nvar _onProviderError = /*#__PURE__*/_classPrivateFieldLooseKey(\"onProviderError\");\n\nexport class Init extends Decorate {\n  constructor(options, type, decorateMethod) {\n    super(options, type, decorateMethod); // all injected types added to the registry for overrides\n\n    Object.defineProperty(this, _healthTimer, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _registries, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _updateSub, {\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, _onProviderConnect, {\n      writable: true,\n      value: async () => {\n        this.emit('connected');\n\n        this._isConnected.next(true);\n\n        try {\n          const [hasMeta, cryptoReady] = await Promise.all([this._loadMeta(), this._options.initWasm === false ? Promise.resolve(true) : cryptoWaitReady()]);\n\n          if (hasMeta && !this._isReady && cryptoReady) {\n            this._isReady = true;\n            this.emit('ready', this);\n          }\n\n          _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = setInterval(() => {\n            this._rpcCore.system.health().toPromise().catch(error => l.warn(`Health keepalive check failed: ${error.message}`));\n          }, KEEPALIVE_INTERVAL);\n        } catch (_error) {\n          const error = new Error(`FATAL: Unable to initialize the API: ${_error.message}`);\n          l.error(error);\n          l.error(_error);\n          this.emit('error', error);\n        }\n      }\n    });\n    Object.defineProperty(this, _onProviderDisconnect, {\n      writable: true,\n      value: () => {\n        this.emit('disconnected');\n\n        this._isConnected.next(false);\n\n        this._unsubscribeHealth();\n      }\n    });\n    Object.defineProperty(this, _onProviderError, {\n      writable: true,\n      value: error => {\n        this.emit('error', error);\n      }\n    });\n    this.registry.setKnownTypes(options); // We only register the types (global) if this is not a cloned instance.\n    // Do right up-front, so we get in the user types before we are actually\n    // doing anything on-chain, this ensures we have the overrides in-place\n\n    if (!options.source) {\n      this.registerTypes(options.types);\n    } else {\n      _classPrivateFieldLooseBase(this, _registries)[_registries] = _classPrivateFieldLooseBase(options.source, _registries)[_registries];\n    }\n\n    this._rpc = this._decorateRpc(this._rpcCore, this._decorateMethod);\n    this._rx.rpc = this._decorateRpc(this._rpcCore, this._rxDecorateMethod);\n\n    if (this.supportMulti) {\n      this._queryMulti = this._decorateMulti(this._decorateMethod);\n      this._rx.queryMulti = this._decorateMulti(this._rxDecorateMethod);\n    }\n\n    this._rx.signer = options.signer;\n\n    this._rpcCore.setRegistrySwap(blockHash => this.getBlockRegistry(blockHash));\n\n    if (this.hasSubscriptions) {\n      this._rpcCore.provider.on('disconnected', _classPrivateFieldLooseBase(this, _onProviderDisconnect)[_onProviderDisconnect]);\n\n      this._rpcCore.provider.on('error', _classPrivateFieldLooseBase(this, _onProviderError)[_onProviderError]);\n\n      this._rpcCore.provider.on('connected', _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]);\n    } else {\n      l.warn('Api will be available in a limited mode since the provider does not support subscriptions');\n    } // If the provider was instantiated earlier, and has already emitted a\n    // 'connected' event, then the `on('connected')` won't fire anymore. To\n    // cater for this case, we call manually `this._onProviderConnect`.\n\n\n    if (this._rpcCore.provider.isConnected) {\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      _classPrivateFieldLooseBase(this, _onProviderConnect)[_onProviderConnect]();\n    }\n  }\n  /**\n   * @description Decorates a registry based on the runtime version\n   */\n\n\n  _initRegistry(registry, chain, version, metadata, chainProps) {\n    registry.setChainProperties(chainProps || this.registry.getChainProperties());\n    registry.setKnownTypes(this._options);\n    registry.register(getSpecTypes(registry, chain, version.specName, version.specVersion));\n    registry.setHasher(getSpecHasher(registry, chain, version.specName)); // for bundled types, pull through the aliases defined\n\n    if (registry.knownTypes.typesBundle) {\n      registry.knownTypes.typesAlias = getSpecAlias(registry, chain, version.specName);\n    }\n\n    registry.setMetadata(metadata, undefined, _objectSpread(_objectSpread({}, getSpecExtensions(registry, chain, version.specName)), this._options.signedExtensions || {}));\n    return registry;\n  }\n  /**\n   * @description Sets up a registry based on the block hash defined\n   */\n\n\n  async getBlockRegistry(blockHash) {\n    const existingViaHash = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      lastBlockHash\n    }) => lastBlockHash && u8aEq(lastBlockHash, blockHash));\n\n    if (existingViaHash) {\n      return existingViaHash;\n    } // ensure we have everything required\n\n\n    assert(this._genesisHash && this._runtimeVersion, 'Cannot retrieve data on an uninitialized chain'); // We have to assume that on the RPC layer the calls used here does not call back into\n    // the registry swap, so getHeader & getRuntimeVersion should not be historic\n\n    const header = this.registry.createType('HeaderPartial', this._genesisHash.eq(blockHash) ? {\n      number: BN_ZERO,\n      parentHash: this._genesisHash\n    } : await this._rpcCore.chain.getHeader.json(blockHash).toPromise());\n    assert(!header.parentHash.isEmpty, 'Unable to retrieve header and parent from supplied hash'); // get the runtime version, either on-chain or via an known upgrade history\n\n    const [firstVersion, lastVersion] = getUpgradeVersion(this._genesisHash, header.number);\n    const version = this.registry.createType('RuntimeVersionPartial', firstVersion && (lastVersion || firstVersion.specVersion.eq(this._runtimeVersion.specVersion)) ? {\n      specName: this._runtimeVersion.specName,\n      specVersion: firstVersion.specVersion\n    } : await this._rpcCore.state.getRuntimeVersion.json(header.parentHash).toPromise()); // check for pre-existing registries\n\n    const existingViaVersion = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n      specVersion\n    }) => specVersion.eq(version.specVersion));\n\n    if (existingViaVersion) {\n      existingViaVersion.lastBlockHash = blockHash;\n      return existingViaVersion;\n    } // nothing has been found, construct new\n\n\n    const metadata = new Metadata(this.registry, await this._rpcCore.state.getMetadata.raw(header.parentHash).toPromise());\n\n    const registry = this._initRegistry(new TypeRegistry(blockHash), this._runtimeChain, version, metadata); // add our new registry\n\n\n    const result = {\n      isDefault: false,\n      lastBlockHash: blockHash,\n      metadata,\n      metadataConsts: null,\n      registry,\n      specVersion: version.specVersion\n    };\n\n    _classPrivateFieldLooseBase(this, _registries)[_registries].push(result); // TODO This could be useful for historic, disabled due to cross-looping, i.e. .at queries\n    // this._detectCapabilities(registry, blockHash);\n\n\n    return result;\n  }\n\n  async _loadMeta() {\n    var _this$_options$source;\n\n    // on re-connection to the same chain, we don't want to re-do everything from chain again\n    if (this._isReady) {\n      return true;\n    }\n\n    this._unsubscribeUpdates(); // only load from on-chain if we are not a clone (default path), alternatively\n    // just use the values from the source instance provided\n\n\n    [this._genesisHash, this._runtimeMetadata] = (_this$_options$source = this._options.source) !== null && _this$_options$source !== void 0 && _this$_options$source._isReady ? await this._metaFromSource(this._options.source) : await this._metaFromChain(this._options.metadata);\n    return this._initFromMeta(this._runtimeMetadata);\n  } // eslint-disable-next-line @typescript-eslint/require-await\n\n\n  async _metaFromSource(source) {\n    this._extrinsicType = source.extrinsicVersion;\n    this._runtimeChain = source.runtimeChain;\n    this._runtimeVersion = source.runtimeVersion;\n    const methods = []; // manually build a list of all available methods in this RPC, we are\n    // going to filter on it to align the cloned RPC without making a call\n\n    Object.keys(source.rpc).forEach(section => {\n      Object.keys(source.rpc[section]).forEach(method => {\n        methods.push(`${section}_${method}`);\n      });\n    });\n\n    this._filterRpcMethods(methods);\n\n    return [source.genesisHash, source.runtimeMetadata];\n  }\n\n  _detectCapabilities(registry, blockHash) {\n    detectedCapabilities(this._rx, blockHash).toPromise().then(types => {\n      if (Object.keys(types).length) {\n        registry.register(types);\n        l.debug(() => `Capabilities detected${blockHash ? ` (${u8aToHex(u8aToU8a(blockHash))})` : ''}: ${stringify(types)}`);\n      }\n    }).catch(undefined);\n    return true;\n  } // subscribe to metadata updates, inject the types on changes\n\n\n  _subscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub] || !this.hasSubscriptions) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = this._rpcCore.state.subscribeRuntimeVersion().pipe(switchMap(version => {\n      var _this$_runtimeVersion;\n\n      return (// only retrieve the metadata when the on-chain version has been changed\n        (_this$_runtimeVersion = this._runtimeVersion) !== null && _this$_runtimeVersion !== void 0 && _this$_runtimeVersion.specVersion.eq(version.specVersion) ? of(false) : this._rpcCore.state.getMetadata().pipe(map(metadata => {\n          l.log(`Runtime version updated to spec=${version.specVersion.toString()}, tx=${version.transactionVersion.toString()}`);\n          this._runtimeMetadata = metadata;\n          this._runtimeVersion = version;\n          this._rx.runtimeVersion = version; // update the default registry version\n\n          const thisRegistry = _classPrivateFieldLooseBase(this, _registries)[_registries].find(({\n            isDefault\n          }) => isDefault);\n\n          assert(thisRegistry, 'Initialization error, cannot find the default registry'); // setup the data as per the current versions\n\n          thisRegistry.metadata = metadata;\n          thisRegistry.metadataConsts = null;\n          thisRegistry.specVersion = version.specVersion; // clear the registry types to ensure that we override correctly\n\n          this._initRegistry(thisRegistry.registry.init(), this._runtimeChain, version, metadata);\n\n          this.injectMetadata(metadata, false, thisRegistry.registry);\n          return this._detectCapabilities(thisRegistry.registry);\n        }))\n      );\n    })).subscribe();\n  }\n\n  async _metaFromChain(optMetadata) {\n    const [genesisHash, runtimeVersion, chain, chainProps, rpcMethods, chainMetadata] = await Promise.all([this._rpcCore.chain.getBlockHash(0).toPromise(), this._rpcCore.state.getRuntimeVersion().toPromise(), this._rpcCore.system.chain().toPromise(), this._rpcCore.system.properties().toPromise(), this._rpcCore.rpc.methods().toPromise(), optMetadata ? Promise.resolve(null) : this._rpcCore.state.getMetadata().toPromise()]); // set our chain version & genesisHash as returned\n\n    this._runtimeChain = chain;\n    this._runtimeVersion = runtimeVersion;\n    this._rx.runtimeVersion = runtimeVersion; // retrieve metadata, either from chain  or as pass-in via options\n\n    const metadataKey = `${genesisHash.toHex() || '0x'}-${runtimeVersion.specVersion.toString()}`;\n    const metadata = chainMetadata || (optMetadata && optMetadata[metadataKey] ? new Metadata(this.registry, optMetadata[metadataKey]) : await this._rpcCore.state.getMetadata().toPromise()); // initializes the registry & RPC\n\n    this._initRegistry(this.registry, chain, runtimeVersion, metadata, chainProps);\n\n    this._filterRpc(rpcMethods, getSpecRpc(this.registry, chain, runtimeVersion.specName));\n\n    this._subscribeUpdates(); // setup the initial registry, when we have none\n\n\n    if (!_classPrivateFieldLooseBase(this, _registries)[_registries].length) {\n      _classPrivateFieldLooseBase(this, _registries)[_registries].push({\n        isDefault: true,\n        lastBlockHash: null,\n        metadata,\n        metadataConsts: null,\n        registry: this.registry,\n        specVersion: runtimeVersion.specVersion\n      });\n    } // get unique types & validate\n\n\n    metadata.getUniqTypes(false);\n    return [genesisHash, metadata];\n  }\n\n  _initFromMeta(metadata) {\n    this._extrinsicType = metadata.asLatest.extrinsic.version.toNumber();\n    this._rx.extrinsicType = this._extrinsicType;\n    this._rx.genesisHash = this._genesisHash;\n    this._rx.runtimeVersion = this._runtimeVersion; // must be set here\n    // inject metadata and adjust the types as detected\n\n    this.injectMetadata(metadata, true); // derive is last, since it uses the decorated rx\n\n    this._rx.derive = this._decorateDeriveRx(this._rxDecorateMethod);\n    this._derive = this._decorateDerive(this._decorateMethod); // detect the on-chain capabilities\n\n    this._detectCapabilities(this.registry);\n\n    return true;\n  }\n\n  _unsubscribeHealth() {\n    if (_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]) {\n      clearInterval(_classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer]);\n      _classPrivateFieldLooseBase(this, _healthTimer)[_healthTimer] = null;\n    }\n  }\n\n  _unsubscribeUpdates() {\n    if (_classPrivateFieldLooseBase(this, _updateSub)[_updateSub]) {\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub].unsubscribe();\n\n      _classPrivateFieldLooseBase(this, _updateSub)[_updateSub] = null;\n    }\n  }\n\n  _unsubscribe() {\n    this._unsubscribeHealth();\n\n    this._unsubscribeUpdates();\n  }\n\n}"]},"metadata":{},"sourceType":"module"}