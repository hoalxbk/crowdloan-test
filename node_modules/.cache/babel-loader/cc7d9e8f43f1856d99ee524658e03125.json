{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aToHex } from '@polkadot/util';\n/**\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param types - The array of Constructor to decode the U8a against.\n */\n\nexport function decodeU8a(registry, u8a, _types, _keys) {\n  const [types, keys] = Array.isArray(_types) ? [_types, _keys || []] : [Object.values(_types), Object.keys(_types)];\n  const result = [];\n  let offset = 0;\n\n  for (let i = 0; i < types.length; i++) {\n    const Type = types[i];\n\n    try {\n      const value = new Type(registry, u8a.subarray(offset));\n      result.push(value);\n      offset += value.encodedLength;\n    } catch (error) {\n      let rawType;\n\n      try {\n        rawType = new Type(registry).toRawType();\n      } catch {\n        rawType = '';\n      }\n\n      throw new Error(`decodeU8a: failed at ${u8aToHex(u8a.subarray(offset).slice(0, 8))}… on ${keys[i] ? `${keys[i]}` : ''}${rawType ? `: ${rawType}` : ''}:: ${error.message}`);\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/types/codec/utils/decodeU8a.js"],"names":["u8aToHex","decodeU8a","registry","u8a","_types","_keys","types","keys","Array","isArray","Object","values","result","offset","i","length","Type","value","subarray","push","encodedLength","error","rawType","toRawType","Error","slice","message"],"mappings":"AAAA;AACA;AACA,SAASA,QAAT,QAAyB,gBAAzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASC,SAAT,CAAmBC,QAAnB,EAA6BC,GAA7B,EAAkCC,MAAlC,EAA0CC,KAA1C,EAAiD;AACtD,QAAM,CAACC,KAAD,EAAQC,IAAR,IAAgBC,KAAK,CAACC,OAAN,CAAcL,MAAd,IAAwB,CAACA,MAAD,EAASC,KAAK,IAAI,EAAlB,CAAxB,GAAgD,CAACK,MAAM,CAACC,MAAP,CAAcP,MAAd,CAAD,EAAwBM,MAAM,CAACH,IAAP,CAAYH,MAAZ,CAAxB,CAAtE;AACA,QAAMQ,MAAM,GAAG,EAAf;AACA,MAAIC,MAAM,GAAG,CAAb;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,KAAK,CAACS,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,UAAME,IAAI,GAAGV,KAAK,CAACQ,CAAD,CAAlB;;AAEA,QAAI;AACF,YAAMG,KAAK,GAAG,IAAID,IAAJ,CAASd,QAAT,EAAmBC,GAAG,CAACe,QAAJ,CAAaL,MAAb,CAAnB,CAAd;AACAD,MAAAA,MAAM,CAACO,IAAP,CAAYF,KAAZ;AACAJ,MAAAA,MAAM,IAAII,KAAK,CAACG,aAAhB;AACD,KAJD,CAIE,OAAOC,KAAP,EAAc;AACd,UAAIC,OAAJ;;AAEA,UAAI;AACFA,QAAAA,OAAO,GAAG,IAAIN,IAAJ,CAASd,QAAT,EAAmBqB,SAAnB,EAAV;AACD,OAFD,CAEE,MAAM;AACND,QAAAA,OAAO,GAAG,EAAV;AACD;;AAED,YAAM,IAAIE,KAAJ,CAAW,wBAAuBxB,QAAQ,CAACG,GAAG,CAACe,QAAJ,CAAaL,MAAb,EAAqBY,KAArB,CAA2B,CAA3B,EAA8B,CAA9B,CAAD,CAAmC,QAAOlB,IAAI,CAACO,CAAD,CAAJ,GAAW,GAAEP,IAAI,CAACO,CAAD,CAAI,EAArB,GAAyB,EAAG,GAAEQ,OAAO,GAAI,KAAIA,OAAQ,EAAhB,GAAoB,EAAG,MAAKD,KAAK,CAACK,OAAQ,EAAnK,CAAN;AACD;AACF;;AAED,SAAOd,MAAP;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { u8aToHex } from '@polkadot/util';\n/**\n * Given an u8a, and an array of Type constructors, decode the u8a against the\n * types, and return an array of decoded values.\n *\n * @param u8a - The u8a to decode.\n * @param types - The array of Constructor to decode the U8a against.\n */\n\nexport function decodeU8a(registry, u8a, _types, _keys) {\n  const [types, keys] = Array.isArray(_types) ? [_types, _keys || []] : [Object.values(_types), Object.keys(_types)];\n  const result = [];\n  let offset = 0;\n\n  for (let i = 0; i < types.length; i++) {\n    const Type = types[i];\n\n    try {\n      const value = new Type(registry, u8a.subarray(offset));\n      result.push(value);\n      offset += value.encodedLength;\n    } catch (error) {\n      let rawType;\n\n      try {\n        rawType = new Type(registry).toRawType();\n      } catch {\n        rawType = '';\n      }\n\n      throw new Error(`decodeU8a: failed at ${u8aToHex(u8a.subarray(offset).slice(0, 8))}… on ${keys[i] ? `${keys[i]}` : ''}${rawType ? `: ${rawType}` : ''}:: ${error.message}`);\n    }\n  }\n\n  return result;\n}"]},"metadata":{},"sourceType":"module"}