{"ast":null,"code":"// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { createClass } from \"./createClass.js\"; // With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\n\nfunction checkInstance(value, created) {\n  const u8a = created.toU8a();\n  const rawType = created.toRawType();\n  assert(u8aEq(value, u8a) || // when length-prefixed from hex, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && value.length === created.length, () => `${rawType}:: Decoded input doesn't match input, received ${u8aToHex(value, 512)} (${value.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], {\n  blockHash,\n  isPedantic\n} = {}) {\n  const created = new Type(registry, ...params);\n  const value = params[0];\n\n  if (isPedantic) {\n    if (isU8a(value)) {\n      checkInstance(value, created);\n    } else if (isHex(value)) {\n      checkInstance(u8aToU8a(value.toString()), created);\n    }\n  }\n\n  if (blockHash) {\n    created.createdAtHash = createType(registry, 'Hash', blockHash);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n  try {\n    return initType(registry, createClass(registry, type), params, options);\n  } catch (error) {\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/types/create/createType.js"],"names":["assert","isHex","isU8a","u8aEq","u8aToHex","u8aToU8a","createClass","checkInstance","value","created","u8a","toU8a","rawType","toRawType","includes","length","initType","registry","Type","params","blockHash","isPedantic","toString","createdAtHash","createType","createTypeUnsafe","type","options","error","Error","message"],"mappings":"AAAA;AACA;AACA,SAASA,MAAT,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+BC,KAA/B,EAAsCC,QAAtC,EAAgDC,QAAhD,QAAgE,gBAAhE;AACA,SAASC,WAAT,QAA4B,kBAA5B,C,CAEA;AACA;;AACA,SAASC,aAAT,CAAuBC,KAAvB,EAA8BC,OAA9B,EAAuC;AACrC,QAAMC,GAAG,GAAGD,OAAO,CAACE,KAAR,EAAZ;AACA,QAAMC,OAAO,GAAGH,OAAO,CAACI,SAAR,EAAhB;AACAb,EAAAA,MAAM,CAACG,KAAK,CAACK,KAAD,EAAQE,GAAR,CAAL,IAAqB;AAC5B,GAAC,OAAD,EAAU,MAAV,EAAkB,MAAlB,EAA0BI,QAA1B,CAAmCF,OAAnC,KAA+CJ,KAAK,CAACO,MAAN,KAAiBN,OAAO,CAACM,MADlE,EAC0E,MAAO,GAAEH,OAAQ,kDAAiDR,QAAQ,CAACI,KAAD,EAAQ,GAAR,CAAa,KAAIA,KAAK,CAACO,MAAO,oBAAmBX,QAAQ,CAACM,GAAD,EAAM,GAAN,CAAW,KAAIA,GAAG,CAACK,MAAO,SADvO,CAAN;AAED,C,CAAC;AACF;;;AAGA,SAASC,QAAT,CAAkBC,QAAlB,EAA4BC,IAA5B,EAAkCC,MAAM,GAAG,EAA3C,EAA+C;AAC7CC,EAAAA,SAD6C;AAE7CC,EAAAA;AAF6C,IAG3C,EAHJ,EAGQ;AACN,QAAMZ,OAAO,GAAG,IAAIS,IAAJ,CAASD,QAAT,EAAmB,GAAGE,MAAtB,CAAhB;AACA,QAAMX,KAAK,GAAGW,MAAM,CAAC,CAAD,CAApB;;AAEA,MAAIE,UAAJ,EAAgB;AACd,QAAInB,KAAK,CAACM,KAAD,CAAT,EAAkB;AAChBD,MAAAA,aAAa,CAACC,KAAD,EAAQC,OAAR,CAAb;AACD,KAFD,MAEO,IAAIR,KAAK,CAACO,KAAD,CAAT,EAAkB;AACvBD,MAAAA,aAAa,CAACF,QAAQ,CAACG,KAAK,CAACc,QAAN,EAAD,CAAT,EAA6Bb,OAA7B,CAAb;AACD;AACF;;AAED,MAAIW,SAAJ,EAAe;AACbX,IAAAA,OAAO,CAACc,aAAR,GAAwBC,UAAU,CAACP,QAAD,EAAW,MAAX,EAAmBG,SAAnB,CAAlC;AACD;;AAED,SAAOX,OAAP;AACD,C,CAAC;AACF;AACA;;;AAGA,OAAO,SAASgB,gBAAT,CAA0BR,QAA1B,EAAoCS,IAApC,EAA0CP,MAAM,GAAG,EAAnD,EAAuDQ,OAAO,GAAG,EAAjE,EAAqE;AAC1E,MAAI;AACF,WAAOX,QAAQ,CAACC,QAAD,EAAWX,WAAW,CAACW,QAAD,EAAWS,IAAX,CAAtB,EAAwCP,MAAxC,EAAgDQ,OAAhD,CAAf;AACD,GAFD,CAEE,OAAOC,KAAP,EAAc;AACd,UAAM,IAAIC,KAAJ,CAAW,cAAaH,IAAK,OAAME,KAAK,CAACE,OAAQ,EAAjD,CAAN;AACD;AACF;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,OAAO,SAASN,UAAT,CAAoBP,QAApB,EAA8BS,IAA9B,EAAoC,GAAGP,MAAvC,EAA+C;AACpD,SAAOM,gBAAgB,CAACR,QAAD,EAAWS,IAAX,EAAiBP,MAAjB,CAAvB;AACD","sourcesContent":["// Copyright 2017-2021 @polkadot/types authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { assert, isHex, isU8a, u8aEq, u8aToHex, u8aToU8a } from '@polkadot/util';\nimport { createClass } from \"./createClass.js\";\n\n// With isPedantic, actually check that the encoding matches that supplied. This\n// is much slower, but verifies that we have the correct types defined\nfunction checkInstance(value, created) {\n  const u8a = created.toU8a();\n  const rawType = created.toRawType();\n  assert(u8aEq(value, u8a) || // when length-prefixed from hex, just check the actual length\n  ['Bytes', 'Text', 'Type'].includes(rawType) && value.length === created.length, () => `${rawType}:: Decoded input doesn't match input, received ${u8aToHex(value, 512)} (${value.length} bytes), created ${u8aToHex(u8a, 512)} (${u8a.length} bytes)`);\n} // Initializes a type with a value. This also checks for fallbacks and in the cases\n// where isPedantic is specified (storage decoding), also check the format/structure\n\n\nfunction initType(registry, Type, params = [], {\n  blockHash,\n  isPedantic\n} = {}) {\n  const created = new Type(registry, ...params);\n  const value = params[0];\n\n  if (isPedantic) {\n    if (isU8a(value)) {\n      checkInstance(value, created);\n    } else if (isHex(value)) {\n      checkInstance(u8aToU8a(value.toString()), created);\n    }\n  }\n\n  if (blockHash) {\n    created.createdAtHash = createType(registry, 'Hash', blockHash);\n  }\n\n  return created;\n} // An unsafe version of the `createType` below. It's unsafe because the `type`\n// argument here can be any string, which, when it cannot parse, will yield a\n// runtime error.\n\n\nexport function createTypeUnsafe(registry, type, params = [], options = {}) {\n  try {\n    return initType(registry, createClass(registry, type), params, options);\n  } catch (error) {\n    throw new Error(`createType(${type}):: ${error.message}`);\n  }\n}\n/**\n * Create an instance of a `type` with a given `params`.\n * @param type - A recognizable string representing the type to create an\n * instance from\n * @param params - The value to instantiate the type with\n */\n\nexport function createType(registry, type, ...params) {\n  return createTypeUnsafe(registry, type, params);\n}"]},"metadata":{},"sourceType":"module"}