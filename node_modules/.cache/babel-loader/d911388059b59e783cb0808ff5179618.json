{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\n\n\nimport { Raw } from '@polkadot/types/codec';\nimport { assert, compactAddLength, compactStripLength, isNull, isUndefined, stringCamelCase, stringify, stringLowerFirst, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getHasher } from \"./getHasher.js\";\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return u8aConcat(xxhashAsU8a(prefix, 128), xxhashAsU8a(method, 128));\n}\n\nfunction createKeyRaw(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  return u8aConcat(createPrefixedKey(itemFn), ...keys.map((type, index) => {\n    const arg = args[index];\n    assert(!isUndefined(arg) && !isNull(arg), () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} has a null or undefined argument at position ${index}`);\n    return hashers[index](registry.createType(type.toString(), arg).toU8a());\n  }));\n}\n\nfunction createKey(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  assert(Array.isArray(args) && args.length === keys.length, () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found ${stringify(args)}`); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key : type.isDoubleMap ? type.asDoubleMap.key1 : type.asNMap.keyVec[0]; // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', registry.createType(outputType.toString()).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', outputType), 0)\n  });\n  return (...args) => registry.createType('StorageKey', iterFn(...args), {\n    method,\n    section\n  });\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n    assert(args.length === 0 || type.isDoubleMap && args.length === 1 || type.isNMap && args.length === type.asNMap.hashers.length - 1, () => `Iteration ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be one less than the full arguments, found [${args.join(', ')}]`);\n\n    if (args.length) {\n      if (type.isDoubleMap) {\n        return new Raw(registry, createKeyRaw(registry, itemFn, [type.asDoubleMap.key1], [getHasher(type.asDoubleMap.hasher)], args));\n      } else if (type.isNMap) {\n        const keys = [...type.asNMap.keyVec];\n        const hashers = type.asNMap.hashers.map(h => getHasher(h)); // remove the last entry\n\n        keys.pop();\n        hashers.pop();\n        return new Raw(registry, createKeyRaw(registry, itemFn, keys, hashers, args));\n      }\n    }\n\n    return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isPlain ? options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, [], [], []) : type.isMap ? createKey(registry, itemFn, [type.asMap.key], [getHasher(type.asMap.hasher)], [arg]) : type.isDoubleMap ? createKey(registry, itemFn, [type.asDoubleMap.key1, type.asDoubleMap.key2], [getHasher(type.asDoubleMap.hasher), getHasher(type.asDoubleMap.key2Hasher)], arg) : createKey(registry, itemFn, type.asNMap.keyVec, type.asNMap.hashers.map(h => getHasher(h)), arg));\n\n  if (type.isMap || type.isDoubleMap || type.isNMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}","map":{"version":3,"sources":["/Users/lehoa/icetea/work/node_modules/@polkadot/metadata/decorate/storage/createFunction.js"],"names":["_defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","Raw","assert","compactAddLength","compactStripLength","isNull","isUndefined","stringCamelCase","stringify","stringLowerFirst","u8aConcat","u8aToU8a","xxhashAsU8a","getHasher","createPrefixedKey","method","prefix","createKeyRaw","registry","itemFn","hashers","args","section","map","type","index","arg","createType","toString","toU8a","createKey","Array","isArray","expandWithMeta","meta","_storageFn","storageFn","toJSON","storage","extendHeadMeta","documentation","name","iterFn","outputType","isMap","asMap","isDoubleMap","asDoubleMap","key1","asNMap","keyVec","fallback","toHex","modifier","extendPrefixedMap","iterKey","isNMap","join","hasher","h","pop","createFunction","options","isPlain","skipHashing","key2","key2Hasher","keyPrefix"],"mappings":"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","sourcesContent":["import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// Copyright 2017-2021 @polkadot/metadata authors & contributors\n// SPDX-License-Identifier: Apache-2.0\nimport { Raw } from '@polkadot/types/codec';\nimport { assert, compactAddLength, compactStripLength, isNull, isUndefined, stringCamelCase, stringify, stringLowerFirst, u8aConcat, u8aToU8a } from '@polkadot/util';\nimport { xxhashAsU8a } from '@polkadot/util-crypto';\nimport { getHasher } from \"./getHasher.js\";\n\nfunction createPrefixedKey({\n  method,\n  prefix\n}) {\n  return u8aConcat(xxhashAsU8a(prefix, 128), xxhashAsU8a(method, 128));\n}\n\nfunction createKeyRaw(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  return u8aConcat(createPrefixedKey(itemFn), ...keys.map((type, index) => {\n    const arg = args[index];\n    assert(!isUndefined(arg) && !isNull(arg), () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} has a null or undefined argument at position ${index}`);\n    return hashers[index](registry.createType(type.toString(), arg).toU8a());\n  }));\n}\n\nfunction createKey(registry, itemFn, keys, hashers, args) {\n  const {\n    method,\n    section\n  } = itemFn;\n  assert(Array.isArray(args) && args.length === keys.length, () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found ${stringify(args)}`); // as per createKey, always add the length prefix (underlying it is Bytes)\n\n  return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));\n} // attach the metadata to expand to a StorageFunction\n\n/** @internal */\n\n\nfunction expandWithMeta({\n  meta,\n  method,\n  prefix,\n  section\n}, _storageFn) {\n  const storageFn = _storageFn;\n  storageFn.meta = meta;\n  storageFn.method = stringLowerFirst(method);\n  storageFn.prefix = prefix;\n  storageFn.section = section; // explicitly add the actual method in the toJSON, this gets used to determine caching and without it\n  // instances (e.g. collective) will not work since it is only matched on param meta\n\n  storageFn.toJSON = () => _objectSpread(_objectSpread({}, meta.toJSON()), {}, {\n    storage: {\n      method,\n      prefix,\n      section\n    }\n  });\n\n  return storageFn;\n}\n/** @internal */\n\n\nfunction extendHeadMeta(registry, {\n  meta: {\n    documentation,\n    name,\n    type\n  },\n  section\n}, {\n  method\n}, iterFn) {\n  const outputType = type.isMap ? type.asMap.key : type.isDoubleMap ? type.asDoubleMap.key1 : type.asNMap.keyVec[0]; // metadata with a fallback value using the type of the key, the normal\n  // meta fallback only applies to actual entry values, create one for head\n\n  iterFn.meta = registry.createType('StorageEntryMetadataLatest', {\n    documentation,\n    fallback: registry.createType('Bytes', registry.createType(outputType.toString()).toHex()),\n    modifier: registry.createType('StorageEntryModifierLatest', 1),\n    // required\n    name,\n    type: registry.createType('StorageEntryTypeLatest', registry.createType('Type', outputType), 0)\n  });\n  return (...args) => registry.createType('StorageKey', iterFn(...args), {\n    method,\n    section\n  });\n} // attach the full list hashing for prefixed maps\n\n/** @internal */\n\n\nfunction extendPrefixedMap(registry, itemFn, storageFn) {\n  const {\n    meta: {\n      type\n    },\n    method,\n    section\n  } = itemFn;\n  storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {\n    assert(args.length === 0 || type.isDoubleMap && args.length === 1 || type.isNMap && args.length === type.asNMap.hashers.length - 1, () => `Iteration ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be one less than the full arguments, found [${args.join(', ')}]`);\n\n    if (args.length) {\n      if (type.isDoubleMap) {\n        return new Raw(registry, createKeyRaw(registry, itemFn, [type.asDoubleMap.key1], [getHasher(type.asDoubleMap.hasher)], args));\n      } else if (type.isNMap) {\n        const keys = [...type.asNMap.keyVec];\n        const hashers = type.asNMap.hashers.map(h => getHasher(h)); // remove the last entry\n\n        keys.pop();\n        hashers.pop();\n        return new Raw(registry, createKeyRaw(registry, itemFn, keys, hashers, args));\n      }\n    }\n\n    return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));\n  });\n  return storageFn;\n}\n/** @internal */\n\n\nexport function createFunction(registry, itemFn, options) {\n  const {\n    meta: {\n      type\n    }\n  } = itemFn; // Can only have zero or one argument:\n  //   - storage.system.account(address)\n  //   - storage.timestamp.blockPeriod()\n  // For higher-map queries the params are passed in as an tuple, [key1, key2]\n\n  const storageFn = expandWithMeta(itemFn, arg => type.isPlain ? options.skipHashing ? compactAddLength(u8aToU8a(options.key)) : createKey(registry, itemFn, [], [], []) : type.isMap ? createKey(registry, itemFn, [type.asMap.key], [getHasher(type.asMap.hasher)], [arg]) : type.isDoubleMap ? createKey(registry, itemFn, [type.asDoubleMap.key1, type.asDoubleMap.key2], [getHasher(type.asDoubleMap.hasher), getHasher(type.asDoubleMap.key2Hasher)], arg) : createKey(registry, itemFn, type.asNMap.keyVec, type.asNMap.hashers.map(h => getHasher(h)), arg));\n\n  if (type.isMap || type.isDoubleMap || type.isNMap) {\n    extendPrefixedMap(registry, itemFn, storageFn);\n  }\n\n  storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];\n\n  return storageFn;\n}"]},"metadata":{},"sourceType":"module"}